// TagWrapper.cpp - implementation of TagWrapper using minc2_simple API\n\n#include "TagWrapper.hpp"\n\n// Include the minc2_simple header that declares the C API.\nextern "C" {\n#include "minc2-simple.h" // path relative to include directories set in CMake\n}\n\n#include <cstring> // for strdup if needed\n\nTagWrapper::TagWrapper() : tags_(nullptr), n_volumes_(0) {}\n\nTagWrapper::~TagWrapper() {\n    clear();\n}\n\nvoid TagWrapper::clear() {\n    if (tags_) {\n        // minc2_tags_free frees the structure and any allocated strings/arrays\n        minc2_tags_free(tags_);\n        tags_ = nullptr;\n    }\n    points_.clear();\n    labels_.clear();\n    n_volumes_ = 0;\n}\n\nbool TagWrapper::load(const std::string& path) {\n    clear();\n\n    // Allocate the tags structure (zeroed)\n    tags_ = minc2_tags_allocate0();\n    if (!tags_) {\n        return false;\n    }\n\n    // Load the tag file using the C API. It returns VIO_OK on success.\n    if (minc2_tags_load(path.c_str(), tags_) != VIO_OK) {\n        clear();\n        return false;\n    }\n\n    // Store volume count\n    n_volumes_ = tags_->n_volumes;\n\n    // Copy points for the first volume (volume index 0).\n    // The C API stores points as three separate double arrays per volume.\n    // We will read tags_->tags_volume1 (double*) which contains n_tag_points * 3 values.\n    int count = tags_->n_tag_points;\n    points_.reserve(count);\n    const double* vol1 = tags_->tags_volume1;\n    for (int i = 0; i < count; ++i) {\n        glm::vec3 p;\n        p.x = static_cast<float>(vol1[i * 3 + 0]);\n        p.y = static_cast<float>(vol1[i * 3 + 1]);\n        p.z = static_cast<float>(vol1[i * 3 + 2]);\n        points_.push_back(p);\n    }\n\n    // Copy labels if present. The C struct has a char** labels pointer.\n    // It may be NULL or individual entries may be NULL. We store empty strings for missing labels.\n    labels_.reserve(count);\n    if (tags_->labels) {\n        for (int i = 0; i < count; ++i) {\n            const char* lbl = tags_->labels[i];\n            labels_.emplace_back(lbl ? lbl : "");\n        }\n    } else {\n        // No label array â€“ fill with empty strings\n        for (int i = 0; i < count; ++i) {\n            labels_.emplace_back("");\n        }\n    }\n\n    return true;\n}\n